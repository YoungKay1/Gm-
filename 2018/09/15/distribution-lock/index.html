<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,Redis,Zookeeper,Spring Boot,Spring,">










<meta name="description" content="Preface 在现代互联网，通常都是伴随着分布式、高并发等，在某些业务中例如下订单扣减库存，如果不对库存资源做临界处理，在并发量大的时候会出现库存不准确的情况。在单个服务的情况下可以通过Java自带的一些锁对临界资源进行处理，例如synchronized、Reentrantlock，甚至是通过无锁技术（比如RangeBuffer）都可以实现同一个JVM内的锁。But，在能够弹性伸缩的分布式环境">
<meta name="keywords" content="Java,Redis,Zookeeper,Spring Boot,Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式锁的几种实现方式">
<meta property="og:url" content="http://yoursite.com/2018/09/15/distribution-lock/index.html">
<meta property="og:site_name" content="如风过境">
<meta property="og:description" content="Preface 在现代互联网，通常都是伴随着分布式、高并发等，在某些业务中例如下订单扣减库存，如果不对库存资源做临界处理，在并发量大的时候会出现库存不准确的情况。在单个服务的情况下可以通过Java自带的一些锁对临界资源进行处理，例如synchronized、Reentrantlock，甚至是通过无锁技术（比如RangeBuffer）都可以实现同一个JVM内的锁。But，在能够弹性伸缩的分布式环境">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cdn.yangbingdong.com/img/distribute-lock/distribute-lock-banner.png">
<meta property="og:updated_time" content="2018-12-09T10:09:00.026Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分布式锁的几种实现方式">
<meta name="twitter:description" content="Preface 在现代互联网，通常都是伴随着分布式、高并发等，在某些业务中例如下订单扣减库存，如果不对库存资源做临界处理，在并发量大的时候会出现库存不准确的情况。在单个服务的情况下可以通过Java自带的一些锁对临界资源进行处理，例如synchronized、Reentrantlock，甚至是通过无锁技术（比如RangeBuffer）都可以实现同一个JVM内的锁。But，在能够弹性伸缩的分布式环境">
<meta name="twitter:image" content="https://cdn.yangbingdong.com/img/distribute-lock/distribute-lock-banner.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/15/distribution-lock/">





  <title>分布式锁的几种实现方式 | 如风过境</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">如风过境</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/15/distribution-lock/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杨凯">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如风过境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分布式锁的几种实现方式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-15T17:19:33+08:00">
                2018-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://cdn.yangbingdong.com/img/distribute-lock/distribute-lock-banner.png" alt=""></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>在现代互联网，通常都是伴随着分布式、高并发等，在某些业务中例如下订单扣减库存，如果不对库存资源做临界处理，在并发量大的时候会出现库存不准确的情况。在单个服务的情况下可以通过Java自带的一些锁对临界资源进行处理，例如<code>synchronized</code>、<code>Reentrantlock</code>，甚至是通过无锁技术（比如<code>RangeBuffer</code>）都可以实现同一个JVM内的锁。But，在<strong>能够弹性伸缩的分布式环境</strong>下，Java内置的锁显然不能够满足需求，需要借助外部进程实现分布式锁。</p>
</blockquote>
<a id="more"></a>
<h1 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h1><p>分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</p>
<p>常见的是秒杀场景，订单服务部署了多个实例。如秒杀商品有4个，第一个用户购买3个，第二个用户购买2个，理想状态下第一个用户能购买成功，第二个用户提示购买失败，反之亦可。而实际可能出现的情况是，两个用户都得到库存为4，第一个用户买到了3个，更新库存之前，第二个用户下了2个商品的订单，更新库存为2，导致出错。</p>
<p>在上面的场景中，商品的库存是共享变量，面对高并发情形，需要保证对资源的访问互斥。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java API并不能提供分布式锁的能力。分布式系统中，由于分布式系统的分布性，即多线程和多进程并且分布在不同机器中，<code>synchronized</code>和<code>lock</code>这两种锁将<strong>失去原有锁的效果</strong>，需要我们自己实现分布式锁。</p>
<p>常见的锁方案如下：</p>
<ul>
<li>基于数据库实现分布式锁（基本用来玩的）</li>
<li>基于缓存，实现分布式锁，如<code>Redis</code>（业界常用方式）</li>
<li>基于<code>Zookeeper</code>实现分布式锁（性能低）</li>
</ul>
<p>下面我们简单介绍下这几种锁的实现。</p>
<h2 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h2><blockquote>
<p>虽然这种方式基本上<strong>不会被用于生产环境</strong></p>
</blockquote>
<p>基于数据库的锁实现也有两种方式，一是基于数据库表，另一种是基于数据库排他锁。</p>
<h3 id="基于数据库表的增删"><a href="#基于数据库表的增删" class="headerlink" title="基于数据库表的增删"></a>基于数据库表的增删</h3><p>基于数据库表增删是最简单的方式，首先创建一张锁的表主要包含下列字段：方法名，时间戳等字段。</p>
<p>具体使用的方法，当需要锁住某个方法时，往该表中插入一条相关的记录。这边需要注意，方法名是有唯一性约束的，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>执行完毕，需要<code>delete</code>该记录。</p>
<p>当然，这边只是简单介绍一下。对于上述方案可以进行优化，如应用主从数据库，数据之间双向同步。一旦挂掉快速切换到备库上；做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍；使用<code>while</code>循环，直到<code>insert</code>成功再返回成功，虽然并不推荐这样做；还可以记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了，实现<strong>可重入锁</strong>。</p>
<blockquote>
<ul>
<li><strong>可重入锁</strong>：可以再次进入方法A，就是说在释放锁前此线程可以再次进入方法A（方法A递归）。</li>
<li><strong>不可重入锁（自旋锁）</strong>：不可以再次进入方法A，也就是说获得锁进入方法A是此线程在释放锁钱唯一的一次进入方法A。</li>
</ul>
</blockquote>
<h3 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h3><p>我们还可以通过数据库的排他锁来实现分布式锁。基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void lock()&#123;</span><br><span class="line">    connection.setAutoCommit(false)</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(count &lt; 4)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            select * from lock where lock_name=xxx for update;</span><br><span class="line">            if(结果不为空)&#123;</span><br><span class="line">                //代表获取到锁</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //为空或者抛异常的话都表示没有获取到锁</span><br><span class="line">        sleep(1000);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new LockException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。其他没有获取到锁的就会阻塞在上述<code>select</code>语句上，可能的结果有2种，在超时之前获取到了锁，在超时之前仍未获取到锁。</p>
<p>获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，释放锁<code>connection.commit()</code>。</p>
<p>存在的问题主要是性能不高和sql超时的异常。</p>
<h3 id="基于数据库锁的优缺点"><a href="#基于数据库锁的优缺点" class="headerlink" title="基于数据库锁的优缺点"></a>基于数据库锁的优缺点</h3><p>上面两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p>
<ul>
<li>优点是直接借助数据库，简单容易理解。</li>
<li>缺点是操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h2 id="基于Zookeeper"><a href="#基于Zookeeper" class="headerlink" title="基于Zookeeper"></a>基于Zookeeper</h2><p>基于Zookeeper<strong>临时有序节点</strong>可以实现的分布式锁。每个客户端对某个方法加锁时，在Zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
<p>提供的第三方库有<a href="https://curator.apache.org/" target="_blank" rel="noopener">curator</a>，具体使用读者可以自行去看一下。Curator提供的<code>InterProcessMutex</code>是分布式锁的实现。<code>acquire</code>方法获取锁，release方法释放锁。另外，锁释放、阻塞锁、可重入锁等问题都可以有有效解决。讲下阻塞锁的实现，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是就获取到锁，便可以执行业务逻辑。</p>
<p>根据Zookeeper的这些特性，我们来看看如何利用这些特性来实现分布式锁：</p>
<ul>
<li>创建一个锁目录<code>lock</code></li>
<li>线程A获取锁会在<code>lock</code>目录下，创建临时顺序节点</li>
<li>获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁</li>
<li>线程B创建临时节点并获取所有兄弟节点，判断自己不是最小节点，<strong>设置监听(<code>watcher</code>)比自己次小的节点</strong></li>
<li>线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是最小的节点，获得锁</li>
</ul>
<p>最后，Zookeeper实现的分布式锁其实存在一个缺点，那就是<strong>性能上可能并没有缓存服务那么高</strong>。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。并发问题，可能存在网络抖动，客户端和ZK集群的session连接断了，zk集群以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。</p>
<p>下面是简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class CuratorTest &#123;</span><br><span class="line">	private static String address = &quot;127.0.0.1:2181&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(address, retryPolicy);</span><br><span class="line">		client.start();</span><br><span class="line">		//创建分布式锁, 锁空间的根节点路径为/curator/lock</span><br><span class="line">		InterProcessMutex mutex = new InterProcessMutex(client, &quot;/curator/lock&quot;);</span><br><span class="line">		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</span><br><span class="line">		CompletionService&lt;Object&gt; completionService = new ExecutorCompletionService&lt;&gt;(fixedThreadPool);</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			completionService.submit(() -&gt; &#123;</span><br><span class="line">				boolean flag = false;</span><br><span class="line">				try &#123;</span><br><span class="line">					//尝试获取锁，最多等待5秒</span><br><span class="line">					flag = mutex.acquire(5, TimeUnit.SECONDS);</span><br><span class="line">					Thread currentThread = Thread.currentThread();</span><br><span class="line">					if (flag) &#123;</span><br><span class="line">						System.out.println(&quot;线程&quot; + currentThread.getId() + &quot;获取锁成功&quot;);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						System.out.println(&quot;线程&quot; + currentThread.getId() + &quot;获取锁失败&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					//模拟业务逻辑，延时4秒</span><br><span class="line">					Thread.sleep(4000);</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; finally &#123;</span><br><span class="line">					if (flag) &#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							mutex.release();</span><br><span class="line">						&#125; catch (Exception e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		// 等待线程跑完</span><br><span class="line">		int count = 0;</span><br><span class="line">		while (count &lt; 5) &#123;</span><br><span class="line">			if (completionService.poll() != null) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;=========  Complete!&quot;);</span><br><span class="line">		client.close();</span><br><span class="line">		fixedThreadPool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于缓存"><a href="#基于缓存" class="headerlink" title="基于缓存"></a>基于缓存</h2><p>相对于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点，存取速度快很多。而且很多缓存是可以集群部署的，可以解决单点问题。基于缓存的锁有好几种，如Memcached、Redis，下面主要讲解基于Redis的分布式实现。</p>
<h1 id="基于Redis的分布式锁实现"><a href="#基于Redis的分布式锁实现" class="headerlink" title="基于Redis的分布式锁实现"></a>基于Redis的分布式锁实现</h1><blockquote>
<p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li><strong>互斥性。</strong>在任意时刻，只有一个客户端能持有锁。</li>
<li><strong>不会发生死锁。</strong>即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li><strong>具有容错性。</strong>只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li><strong>解铃还须系铃人。</strong>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ol>
</blockquote>
<h2 id="基于Spring-Data-Redis"><a href="#基于Spring-Data-Redis" class="headerlink" title="基于Spring Data Redis"></a>基于Spring Data Redis</h2><p>下面是正确的实现姿势。（使用Spring Data Redis）</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="加锁姿势"><a href="#加锁姿势" class="headerlink" title="加锁姿势"></a>加锁姿势</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">private Boolean setNxEx(String key, String value) &#123;</span><br><span class="line">	return stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; &#123;</span><br><span class="line">		StringRedisConnection stringRedisConn = (StringRedisConnection) connection;</span><br><span class="line">		return stringRedisConn.set(key, value, Expiration.from(1L, TimeUnit.MINUTES), SET_IF_ABSENT);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的<code>setNxEx()</code>方法就只会导致两种结果：</p>
<ol>
<li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li>
<li>已有锁存在，不做任何操作。</li>
</ol>
<p>网上有许多教程在加锁的步骤都<strong>不是原子性</strong>的，有些是先加锁，成功后再设置过期时间；有些将过期时间设置为value，获取锁失败会判断value是否小于当前时间，是则删除在设置新的值。这些方法由于不是原子性，在极端情况（比如多线程，或者代码执行到某一行就宕机了等等）必然会导致锁失效或死锁等情况…</p>
<p>在上面<code>stringRedisConn.set(...)</code>方法中，确保了上锁与设置过期时间的原子性。</p>
<h3 id="解锁姿势"><a href="#解锁姿势" class="headerlink" title="解锁姿势"></a>解锁姿势</h3><p>配置类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisScript&lt;Boolean&gt; releaseLockScript(DLockConfigProperty dLockConfigProperty) &#123;</span><br><span class="line">	DefaultRedisScript&lt;Boolean&gt; redisScript = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">	String scriptLocation = &quot;scripts/release_lock.lua&quot;;</span><br><span class="line">	redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(scriptLocation)));</span><br><span class="line">	redisScript.setResultType(Boolean.class);</span><br><span class="line">	return redisScript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lua脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&apos;GET&apos;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return 1 == redis.call(&apos;DEL&apos;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return false</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">private RedisScript&lt;Boolean&gt; script;</span><br><span class="line"></span><br><span class="line">public void release(String key, String value) &#123;</span><br><span class="line">    stringRedisTemplate.execute(script, singletonList(key), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了配置，解锁就一行代码搞定，虽然简洁，里面也是有很多学问滴。。。</p>
<p>为什么要用Lua脚本？确保原子性，如何保证，请看官网对<code>eval</code>命令的相关解释。上面脚本表达的意思很简单，对比传进来的value是否相等，是则删除锁。value可使用UUID作为当前线程的标识符，<strong>只有但前线程才能解锁</strong>。</p>
<p>网上的错误姿势一般都是执行完业务代码直接删除锁，这样会导致删除了其他线程获的锁。</p>
<p>上面实现的分布式锁是不支持可重入的，需要额外的编码，业界当然早就开源了类似的框架，比如下面介绍的Redisson。</p>
<h2 id="基于Redisson"><a href="#基于Redisson" class="headerlink" title="基于Redisson"></a>基于Redisson</h2><blockquote>
<p><strong><em><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></em></strong> 是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(<code>BitSet</code>, <code>Set</code>, <code>Multimap</code>, <code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>BlockingQueue</code>, <code>Deque</code>, <code>BlockingDeque</code>, <code>Semaphore</code>, <code>Lock</code>, <code>AtomicLong</code>, <code>CountDownLatch</code>, <code>Publish / Subscribe</code>, <code>Bloom filter</code>, <code>Remote service</code>, <code>Spring cache</code>, <code>Executor service</code>, <code>Live Object service</code>, <code>Scheduler service</code>) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</blockquote>
<p>Redisson提供的众多功能中有一项就是可重入锁（Reentrant Lock），具体用法可参考 <strong><em><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">文档</a></em></strong> </p>
<h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;</span><br><span class="line">    &lt;classifier&gt;linux-x86_64&lt;/classifier&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.7.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Slf4j</span><br><span class="line">public class RedissonDLock implements DLock &#123;</span><br><span class="line"></span><br><span class="line">	private final Long waitTime;</span><br><span class="line">	private final Long leaseTime;</span><br><span class="line">	private final TimeUnit timeUnit;</span><br><span class="line">	private final RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">	public RedissonDLock(DLockConfigProperty property) &#123;</span><br><span class="line">		// 设置一些基本属性</span><br><span class="line">		this.waitTime = property.getWaitTime();</span><br><span class="line">		this.leaseTime = property.getLeaseTime();</span><br><span class="line">		this.timeUnit = property.getTimeUnit();</span><br><span class="line"></span><br><span class="line">		Config config = new Config();</span><br><span class="line">		SingleServerConfig singleServerConfig = config.useSingleServer();</span><br><span class="line">		singleServerConfig.setAddress(&quot;redis://&quot; + property.getHost() + &quot;:&quot; + property.getPort());</span><br><span class="line">		if (property.getPassword() != null &amp;&amp; property.getPassword().trim().length() &gt; 0) &#123;</span><br><span class="line">			singleServerConfig.setPassword(property.getPassword());</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;io.netty.channel.epoll.Epoll&quot;);</span><br><span class="line">			// 如果是Linux系统可采用Epoll算法，需要引入 netty-transport-native-epoll</span><br><span class="line">			if (Epoll.isAvailable()) &#123;</span><br><span class="line">				config.setTransportMode(TransportMode.EPOLL);</span><br><span class="line">				log.info(&quot;Starting with optional epoll library&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				log.info(&quot;Starting without optional epoll library&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		redisson = Redisson.create(config);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void tryLockAndAction(LockKeyGenerator lockKeyGenerator, AfterAcquireAction acquireAction) &#123;</span><br><span class="line">		tryLockAndAction(lockKeyGenerator, acquireAction, waitTime, leaseTime, timeUnit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void tryLockAndAction(LockKeyGenerator lockKeyGenerator, AfterAcquireAction acquireAction, Long waitTime, Long leaseTime, TimeUnit timeUnit) &#123;</span><br><span class="line">		tryLockAndAction(lockKeyGenerator, acquireAction, DEFAULT_FAIL_ACQUIRE_ACTION, waitTime, leaseTime, timeUnit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void tryLockAndAction(LockKeyGenerator lockKeyGenerator, AfterAcquireAction acquireAction, FailAcquireAction failAcquireAction, Long waitTime, Long leaseTime, TimeUnit timeUnit) &#123;</span><br><span class="line">		try (LockHolder holder = new LockHolder(redisson.getLock(lockKeyGenerator.getLockKey()))) &#123;</span><br><span class="line">			boolean acquire = holder.getLock().tryLock(waitTime, leaseTime, timeUnit);</span><br><span class="line">			if (acquire) &#123;</span><br><span class="line">				acquireAction.doAction();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				failAcquireAction.doOnFail();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			throw new RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; T tryLockAndExecuteCommand(LockKeyGenerator lockKeyGenerator, AfterAcquireCommand&lt;T&gt; command, FailAcquireAction failAcquireAction, Long waitTime, Long leaseTime, TimeUnit timeUnit) throws Throwable &#123;</span><br><span class="line">		try (LockHolder holder = new LockHolder(redisson.getLock(lockKeyGenerator.getLockKey()))) &#123;</span><br><span class="line">			boolean acquire = holder.getLock().tryLock(waitTime, leaseTime, timeUnit);</span><br><span class="line">			if (acquire) &#123;</span><br><span class="line">				return command.executeCommand();</span><br><span class="line">			&#125;</span><br><span class="line">			failAcquireAction.doOnFail();</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Data</span><br><span class="line">	@Accessors(chain = true)</span><br><span class="line">	@AllArgsConstructor</span><br><span class="line">	private static class LockHolder implements AutoCloseable &#123;</span><br><span class="line">		private RLock lock;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void close() &#123;</span><br><span class="line">			lock.unlockAsync();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般服务器都是Linux系统，引入<code>io.netty.channel.epoll.Epoll</code>采用Epoll方式有助于提升性能</li>
<li>使用<code>try-with-resource</code>方式提高代码优雅性…</li>
</ul>
<h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>Lock注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Lock &#123;</span><br><span class="line"></span><br><span class="line">	String namespace() default &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">	String key();</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt; prefixClass();</span><br><span class="line"></span><br><span class="line">	String separator() default &quot;:&quot;;</span><br><span class="line"></span><br><span class="line">	long waitTime() default 2L;</span><br><span class="line"></span><br><span class="line">	long leaseTime() default 5L;</span><br><span class="line"></span><br><span class="line">	TimeUnit timeUnit() default TimeUnit.SECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切面类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">@Order(1)</span><br><span class="line">public class DLockAspect &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private DLock dLock;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">	private String namespace;</span><br><span class="line"></span><br><span class="line">	@Around(value = &quot;@annotation(lock)&quot;)</span><br><span class="line">	public Object doAround(ProceedingJoinPoint pjp, Lock lock) throws Throwable &#123;</span><br><span class="line">		Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line"></span><br><span class="line">		Object[] args = pjp.getArgs();</span><br><span class="line">		String keySpEL = lock.key();</span><br><span class="line">		String resourceKey = parseSpel(method, args, keySpEL, String.class);</span><br><span class="line"></span><br><span class="line">		String finalKey = buildFinalKey(lock, resourceKey);</span><br><span class="line">		return dLock.tryLockAndExecuteCommand(() -&gt; finalKey, () -&gt; pjp.proceed(pjp.getArgs()), DEFAULT_FAIL_ACQUIRE_ACTION,</span><br><span class="line">				lock.waitTime(), lock.leaseTime(), lock.timeUnit());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String buildFinalKey(Lock lock, String key) &#123;</span><br><span class="line">		return namespace == null || namespace.length() == 0 ? lock.namespace() : namespace +</span><br><span class="line">				lock.separator() +</span><br><span class="line">				lock.prefixClass().getSimpleName() +</span><br><span class="line">				lock.separator() +</span><br><span class="line">				key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了 <strong><em><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions" target="_blank" rel="noopener">SpEL</a></em></strong> 解析锁的Key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class SpelHelper &#123;</span><br><span class="line">	private static final ExpressionParser PARSER = new SpelExpressionParser();</span><br><span class="line">	private static final LocalVariableTableParameterNameDiscoverer DISCOVERER = new LocalVariableTableParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; T parseSpel(Method method, Object[] args, String spel, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">		String[] parameterNames = DISCOVERER.getParameterNames(method);</span><br><span class="line">		requireNonNull(parameterNames);</span><br><span class="line">		EvaluationContext context = buildSpelContext(parameterNames, args);</span><br><span class="line">		Expression expression = PARSER.parseExpression(spel);</span><br><span class="line">		return expression.getValue(context, clazz);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static EvaluationContext buildSpelContext(String[] parameterNames, Object[] args) &#123;</span><br><span class="line">		EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">		for (int len = 0; len &lt; parameterNames.length; len++) &#123;</span><br><span class="line">			context.setVariable(parameterNames[len], args[len]);</span><br><span class="line">		&#125;</span><br><span class="line">		context.setVariable(&quot;args&quot;, args);</span><br><span class="line">		return context;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// @Lock(prefixClass = TestService.class, key = &quot;#id&quot;)</span><br><span class="line">@Lock(prefixClass = TestService.class, key = &quot;#args[0]&quot;)</span><br><span class="line">public void lockTest(Long id) &#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果锁被早被别的线程使用，一般我们使用线程Sleep的方式等待锁释放，但Redisson的底层采用了更优雅的等待策略，通过发布订阅通知其他线程，所以性能也会有所提高。</p>
</blockquote>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>Redisson官方文档： <strong><em><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></em></strong></p>
<p>示例代码：<strong><em><a href="https://github.com/masteranthoneyd/starter/tree/master/dlock" target="_blank" rel="noopener">https://github.com/masteranthoneyd/starter/tree/master/dlock</a></em></strong></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/Zookeeper/" rel="tag"># Zookeeper</a>
          
            <a href="/tags/Spring-Boot/" rel="tag"># Spring Boot</a>
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/28/spring-boot-learning-testing/" rel="next" title="Spring Boot学习之测试篇">
                <i class="fa fa-chevron-left"></i> Spring Boot学习之测试篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/06/spring-boot-learning-redis/" rel="prev" title="Redis杂记">
                Redis杂记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">杨凯</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Preface"><span class="nav-number">1.</span> <span class="nav-text">Preface</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#几种实现方式"><span class="nav-number">2.</span> <span class="nav-text">几种实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基于数据库"><span class="nav-number">2.1.</span> <span class="nav-text">基于数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于数据库表的增删"><span class="nav-number">2.1.1.</span> <span class="nav-text">基于数据库表的增删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于数据库排他锁"><span class="nav-number">2.1.2.</span> <span class="nav-text">基于数据库排他锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于数据库锁的优缺点"><span class="nav-number">2.1.3.</span> <span class="nav-text">基于数据库锁的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于Zookeeper"><span class="nav-number">2.2.</span> <span class="nav-text">基于Zookeeper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于缓存"><span class="nav-number">2.3.</span> <span class="nav-text">基于缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于Redis的分布式锁实现"><span class="nav-number">3.</span> <span class="nav-text">基于Redis的分布式锁实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基于Spring-Data-Redis"><span class="nav-number">3.1.</span> <span class="nav-text">基于Spring Data Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖"><span class="nav-number">3.1.1.</span> <span class="nav-text">依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加锁姿势"><span class="nav-number">3.1.2.</span> <span class="nav-text">加锁姿势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解锁姿势"><span class="nav-number">3.1.3.</span> <span class="nav-text">解锁姿势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于Redisson"><span class="nav-number">3.2.</span> <span class="nav-text">基于Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心代码"><span class="nav-number">3.2.2.</span> <span class="nav-text">核心代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解驱动"><span class="nav-number">3.2.3.</span> <span class="nav-text">注解驱动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Finally"><span class="nav-number">4.</span> <span class="nav-text">Finally</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杨凯</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
